# Open proof obligations / theorem-boundary gaps

This repository contains a computer-assisted verification suite for parts of a proposed Yang–Mills mass gap proof.

A **green software run** (e.g. `verify_full_proof.py` completing) is an *engineering signal* that the code executed and the *CAP checkpoints* passed. It is **not** the same thing as a Clay-standard proof.

The proof status exported to the paper is controlled by:

- `verification/proof_status.json` (claim level and blocking gaps)
- audits (e.g. `os_audit.py`, `verify_continuum_limit.py`, `verify_gap_rigorous.py`)
- exported macros: `single/verification_results.tex` (generated by `export_results_to_latex.py`)

If `proof_status.json` sets `clay_standard=false`, then the global exported status macro `\VerStatus` should not read as “PROVEN” in the Clay sense; theorem-boundary items remain **CONDITIONAL**.

## Blocking gaps (as currently declared)

These items are the current blockers recorded in `verification/proof_status.json`:

1. **Continuum identification / gap transfer not yet constructively implemented**
   - Where it shows up:
     - `mass_gap_certificate.json` (exported via `verify_gap_rigorous.py`)
     - `functional_analysis_gap_transfer.py` (conceptual gap transfer step)
     - exported macros: `\VerMassGapStatus`, `\VerContinuumAuditStatus`
   - What “closure” would require:
     - a fully specified, machine-checkable artifact that ties the *lattice* gap lower bound to a *continuum* Hamiltonian with a spectral gap (including hypotheses, quantitative constants, and a proof hash).

2. **OS reconstruction evidence is theorem-boundary (no machine-checkable RP/OS proof artifact)**
   - Where it shows up:
     - `os_reconstruction_evidence.json` and `rp_evidence.json` (currently use `sha256: "TBD"/"MISSING"` placeholders)
     - `os_audit.py` produces `CONDITIONAL` with reason `theorem_boundary` when these artifacts are placeholders.
     - exported macros: `\VerOSAuditStatus`
   - What “closure” would require:
     - a committed proof artifact (e.g. in `verification/formal_proofs/`) with a stable SHA-256 recorded in the evidence JSON
     - provenance manifests (`*.provenance.json`) binding the artifact to a specific repo state.

3. **Perturbative/UV regime relies on modeled bounds; strict provenance not enforced by default**
   - Where it shows up:
     - UV/perturbative scripts: `verify_perturbative_regime.py`, `verify_uv_handoff.py`
     - obligations bundle: `uv_hypotheses.json` and its SHA exported as `\VerUVHypothesesSHA`
   - What “closure” would require:
     - replacing any “modeled” constants with fully derived and provenance-locked derivations, or else explicitly downgrading the claim to conditional assumptions in the paper
     - enabling strict provenance enforcement for Clay-standard mode (`clay_standard=true`) such that any missing provenance makes the audit fail.

## What the exports currently mean (reader-facing)

The paper reads the current status from:

- `single/verification_results.tex` (generated)
- `verification/certificate_final_audit.json` (generated)

Key macros to look at in the compiled PDF:

- `\VerClaimLevel` (typically `ASSUMPTION-BASED` unless Clay mode is enabled)
- `\VerClayCertified` (`YES`/`NO`)
- `\VerStatus` (`PASS`/`CONDITIONAL`/`FAIL`)

## How to reproduce the exports

From `verification/`:

- Run `export_results_to_latex.py` to regenerate `single/verification_results.tex` and `verification/verification_results.json`.
- Run `generate_final_audit.py` to regenerate `verification/certificate_final_audit.json`.

(These scripts may exit non-zero when the **global** status is `CONDITIONAL`, even if CAP checkpoints are `PASS`.)
